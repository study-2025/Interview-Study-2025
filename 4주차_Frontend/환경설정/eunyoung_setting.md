> ## Webpack
>
> [PPT 01](./eunyoung_asset/1.png)

오늘은 프론트엔드 환경 설정에 대해 알아봅시다.
특히 Webpack, Babel, eslint, prettier, package.json에 대해 알아보도록 합시다.

[PPT 02](./eunyoung_asset/2.png)

React나 Next.js로 개발 후, `npm run build` 명령어를 실행해본 적이 있나요?
명령어를 실행하면 터미널에 빌드를 쭉 하다가 결과적으로 빌드 파일이 생긴 것을 본 적이 있을 것입니다.

그렇다면 이러한 빌드 과정이 어떻게 수행되는 것인지 궁금한 적이 있지 않나요?
지금부터 그 방법에 대해 같이 알아보도록 합시다.

[PPT 03](./eunyoung_asset/3.png)

우리가 개발한 소스 코드를 빌드할 수 있는 것은 바로 '모듈 번들러' 덕분입니다.
여기서 '번들'이라는 것은 '묶는다' 라는 의미를 가집니다.

위 그림은 현재 가장 많이 사용되는 모듈 번들러 중 하나인 웹팩을 소개하는 그림인데요,

왼쪽을 보면 `.js`, `png`, `sass` 등 자바스크립트나 CSS, 이미지 파일 등이 서로 의존성을 가지고 뒤엉켜 있는데,
오른쪽을 보면 비슷한 리소스들끼리 합쳐져 정적인 파일이 되어 있죠?

이처럼 의존성이 있는 여러 리소스들을 하나의 정적인 에셋으로 묶어주는 것이 모듈 번들러 웹팩의 가장 대표적인 기능이라고 할 수 있습니다.
우리가 자주 사용하는 리액트 또한 웹팩을 사용해 프로젝트를 빌드하죠.

그렇다면 모듈 번들러가 왜 필요할까요?
다시 말해, 왜 리소스들을 하나로 묶어야 할까요?

[PPT 04](./eunyoung_asset/4.png)
이미지 출처: [JavaScript 번들러로 본 조선시대 붕당의 이해](https://wormwlrm.github.io/2020/08/12/History-of-JavaScript-Modules-and-Bundlers.html)

이를 알아보기 위해 모듈 번들러의 등장 이전 배경을 함께 살펴봅시다.

네이버 개발자이신 재그지그님께서 자바스크립트 모듈 시스템과 번들러 등장 배경을 재미있게 조선시대 붕당 내용과 조합해서 그림을 만들어주셨는데요,
이 그림을 당장 다 이해할 필요는 없고 일부만 살펴봅시다.

모듈 번들러는 그야말로 자바스크립트 등의 다양한 모듈을 번들해주는 도구인데,
**모듈 번들러의 등장은 자바스크립트 모듈 시스템의 역사와 깊은 관련**이 있습니다.

자바스크립트는 원래 웹페이지의 단순 보조 기능을 처리하기 위한 용도로 사용되었기 때문에, **모듈 시스템을 지원하지 않았습니다.**
따라서 클라이언트 사이드 (브라우저 환경)에서 Script 태그를 사용해 외부 자바스크립트 파일을 로드할 수는 있었지만, 결국 **모든 스크립트들이 하나의 파일 내에 있는 것처럼 동작했기 때문에 전역 변수 오염 문제**가 발생했습니다.

그러나 자바스크립트를 클라이언트 사이드 환경에 국한하지 않고 범용적으로 사용하려는 움직임이 생기며 모듈 시스템이 제안되었죠.
그 이후 위 그림 좌측의 V8 엔진 등장 ~ ES6 등장 전까지 모듈 시스템을 표준화하려는 노력이 많이 있었습니다.
(이 과정이 궁금하다면 재그 지그님의 [JavaScript 번들러로 본 조선시대 붕당의 이해](https://wormwlrm.github.io/2020/08/12/History-of-JavaScript-Modules-and-Bundlers.html) 글을 읽어보는 것을 추천합니다.)

그 결과 자바스크립트에서 **ES6를 도입하면서 공식적으로 모듈 시스템을 지원**하기 시작했습니다. (여기서 도입된 모듈 시스템을 ES Module, 줄여서 ESM이라고 부릅니다.)
이때부터 우리가 자주 사용하는 `import/export` 문법을 사용할 수 있게 되었죠.

그러나 모듈 시스템의 도입에 따라 생긴 문제점도 있었습니다.

1. `import`로 여러 파일을 가져오면, 브라우저는 각 파일을 개별적으로 요청해야 했고, **HTTP 요청이 많아져 성능이 저하**되었다. (특히 HTTP/1.1 때는 동시 요청 개수 제한이 있었다.)
2. 초창기 브라우저들은 ES 모듈을 지원하지 않았기 때문에 별도 처리가 필요했다.
3. CommonJS, AMD, UMD, ESM과 같이 서로 다른 모듈 시스템이 혼재하여 개발 환경마다 코드가 호환되지 않았다.
4. 모듈이 많아질수록 모듈 간의 의존 관계를 수동으로 관리해야 했으나, 복잡하고 불편했다.

또한 복잡해지는 클라이언트 사이드 개발과 함께 프로덕트를 개발 절차를 자동화 하고 싶다는 요구 사항도 생겼습니다.

이에 따라 위 그림의 우하단과 같이 빌드, 테스트, 린팅을 자동화해주는 Grunt, Gulp와 같은 도구들과
코드를 최적화 해주는 Google Closure Compiler, 최신 스펙이 적용되지 않은 브라우저에서도 최신 문법을 사용할 수 있게 해주는 Babel과 같은 도구들이 생겨나기 시작합니다.

그리고 나서 **이 모든 기능을 아우르는 모듈 번들러, 웹팩**이 탄생하게 된 것입니다.

[PPT 05](./eunyoung_asset/5.png)
모듈 번들러의 등장 배경을 살펴보았는데, 감이 좀 잡히시나요?
다시 모듈 번들러가 필요했던 이유를 되짚어보겠습니다.

첫번째로 Javascript 모듈 간 종속성 문제가 있었습니다.
모듈 시스템을 도입하면서 전에 있었던 전역 변수 오염 문제 등이 해결되었으나, 수많은 모듈 간 종속성을 신경 쓰기 위해 로딩 순서를 정하는 작업이 매우 비효율적이었죠.

두번째로 HTTP 요청 수와 페이지 로딩 속도 문제가 있었습니다.
자바스크립트 모듈을 적극 활용하게 되면서, 하나의 웹 페이지를 여는 데도 수많은 자바스크립트 파일 요청이 필요해 속도 저하 문제 발생했고, 로딩 속도 최적화 필요성을 느끼게 되었죠.

세번째로 모듈 시스템 호환 문제가 있었습니다.
여러 모듈 시스템을 사용하는 프로젝트에서 어떤 시스템은 브라우저에서 작동하고, 어떤 시스템은 Node.js에서 작동하는 상황에서 모듈을 통합하거나 호환시키려는 노력이 필요했습니다.

네번째로 웹 개발 작업 속도 개선 요구가 있었습니다.
원래 프론트엔드 개발을 할 때는 텍스트 편집기에서 코드를 수정하고 저장한 뒤 브라우저에서 새로 고침을 눌러야만 화면에 변경된 내용을 볼 수 있었기에 웹 개발 작업 속도가 느렸던 문제가 있었습니다.

[PPT 06](./eunyoung_asset/6.png)
따라서 이러한 문제들을 해결하기 위해 모듈 번들러는 다음과 같은 기능을 제공합니다.

첫번째는 의존성 그래프를 활용한 번들링입니다.
번들러는 모듈 간의 의존 관계를 그래프화 해서 필요한 자원들을 번들로 묶어주는 역할을 수행했습니다. 자바스크립트 뿐만 아니라 모든 코드와 에셋 (이미지, CSS 등)도 포함해 작동합니다.

두번째는 코드 스플리팅입니다.
번들링을 수행할 때 사용자에게 필요한 파일 단위로 번들하는 것이 페이지 로딩과 속도에 유리하겠지요.
예를 들어 `/main`, `/about` 페이지가 있을 때 `/main` 으로 들어가는 동안 `/about` 페이지 정보는 사용자에게 필요하지 않을 것입니다. 따라서 번들러는 연관된 파일 단위로 번들해주는 기능을 제공합니다.

세번째는 호환성 해결입니다.
CommonJS와 ESM은 문법과 작동 방식이 다르지만, 번들러는 이를 모두 ES 모듈 형식(ESM)으로 변환하거나, 또는 CommonJS 형식으로 변환하여 최적화된 하나의 번들 파일로 만들어 줍니다.

네번째는 트리 쉐이킹입니다.
번들러는 번들링 과정에서 불필요한 코드를 식별하고 제거합니다. console 같은 개발 코드와 주석을 제거하고, 개발 모드에서 import 문으로 모듈의 모든 배열을 가져오고 그 일부만 사용했을 때, 빌드 시에는 모듈에서 사용한 일부만 import 하는 구문으로 바꿔주는 기능이 있습니다.

[PPT 07](./eunyoung_asset/7.png)
다섯번째는 라이브 리로딩과 핫모듈 교체입니다.
웹팩 번들러는 개발 중에 변경 사항을 자동으로 새로고침 해주고 새로고침 없이 런타임에 브라우저의 모듈을 업데이트하는 라이브 리로딩과 핫모듈 교체를 지원합니다.

이처럼 모듈 번들러 웹팩은 번들링, 모듈 시스템 호환과 동시에 프론트엔드 개발에 유용한 다양한 기능을 제공하고 있습니다.

[PPT 08](./eunyoung_asset/8.png)
다시 처음으로 돌아와서, 그래서 `npm run build`를 하면 어떻게 빌드가 되는건데! 라는 의문이 남아있죠?
이는 리액트에서 빌드 명령어를 실행하면 내부적으로 웹팩 명령어를 실행시키고, 웹팩이 자동으로 여러 리소스들의 의존 관계를 파악해서 합쳐주고 이를 빌드된 파일로 제공해주는 것이라고 이해하면 되겠습니다.

[PPT 09](./eunyoung_asset/9.png)
마지막으로 웹팩을 사용하는 방법을 알아보고 마치겠습니다.

웹팩 설치는 다른 패키지 설치와 다를 점이 없습니다.

```
npm install webpack
```

그리고 웹팩은 설정 파일을 만들어주어야 하는데요, `webpack.config.js` 파일을 생성해주고
위 사진 우측과 같이 entry와 output을 명시해줍니다.

entry는 루트 파일 경로를 명시해주면 되는데요, 예를 들어 `index.js`와 같은 파일을 명시하면 됩니다.
output은 빌드 결과를 저장할 경로를 명시해주면 되구요, 리액트에서는 `dist`라는 폴더를 이용하더랍니다.

이렇게 config 파일을 작성한 뒤에 프로젝트 `package.json` 파일에 아래와 같이 웹팩 명령어를 입력해주면,

```
"scripts": {
    "build": "webpack --config webpack.config.prod.js",
    ...
}
```

`npm run build`를 실행할 때 웹팩이 알아서 entry 파일부터 쭉~ 의존성이 있는 모듈들을 살펴봐주고 불필요한 것 제거해주고 번들링된 결과를 output 경로에 뱉어준답니다.

이제 이해가 되시나요?

그러면 이상으로 모듈 번들러 웹팩에 대한 이해는 마치도록 하겠습니다.

읽어주셔서 감사합니다!

## [Babel](https://mesquite-motorcycle-2de.notion.site/Babel-7052c2e663204eada20102ac25f760d7?pvs=4)

## [Package.json](https://mesquite-motorcycle-2de.notion.site/package-json-b5f5615b2f71498798681fa01b0cf7d7?pvs=4)

## [Eslint, Prettier](https://mesquite-motorcycle-2de.notion.site/ESLint-Prettier-8789914049014c0db778d0cd12277143?pvs=4)
